<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Final Report: Non-photorealistic rendering machine</h1>
		<div style="text-align: center;">Names: Ryan Kwong, Lemuel Sumardy, Thomas Yeoh, Ziran Zhou</div>

		<br>

		Link to webpage: <a href="https://biancanev.github.io/hw-webpages-ilovethomas/final-project/final-report">https://cal-cs184-student.github.io/hw-webpages-ilovethomas/final-project/</a>

		<br>

		Link to GitHub repository: <a href="https://github.com/biancanev/cs184-final-project">https://github.com/biancanev/cs184-final-project</a>

		<h2>Abstract</h2>
		Our project is a non-photorealistic rendering (NPR) machine that allows users to apply different artistic styles to 3D
		models in real-time. We started from scratch with just a blank C++ file. For our final product, we created an
		OpenGL/Imgui interface that is able to properly display three distinct shading techniques: sketch shading, cel shading,
		and watercolor shading. Sketch shading offers a hand-drawn look through the use of density varying cross-hatching. Cel
		shading creates a cartoonish look by discretizing a diffuse or specular shader, creating noticable bands. Watercolor
		shading simulates painted textures through soft gradients and blooming distortions. The user can select the desired
		shading technique through our simple GUI and see the effect applied to the model in real-time. Our custom GUI offers the
		user complete control over the shading parameters used in our NPR shaders, lighting intensity and location, model attributes and camera
		position/orientation. One thing that separates our project from others is that everything is procedurally generated, instead of
		mapping the NPR features from textures.
		<br><br><hr>
		<h2>Technical Approach</h2>
		<h3>GUI</h3>
		<p>
			The camera system is controlled through <b>Position</b>, <b>Front</b>, <b>Up</b>, <b>Right</b>, and <b>Target</b>
			vectors, with the camera orientation defined by Euler angles (<b>Yaw</b>, <b>Pitch</b>, <b>Roll</b>). The
			<b>updateCameraVectors()</b> method first computes the <b>Front</b> vector using spherical coordinates: <b>Front.x</b> =
			cos(Yaw) * cos(Pitch), <b>Front.y</b> = sin(Pitch), <b>Front.z</b> = sin(Yaw) * cos(Pitch). To handle roll, we first
			calculate the initial <b>Right</b> and <b>Up</b> vectors without roll using cross products: <b>rightNoRoll =
				normalize(cross(Front, WorldUp))</b> and <b>upNoRoll = normalize(cross(rightNoRoll, Front))</b>. Then, we apply the
			roll rotation around the <b>Front</b> vector using trigonometry: <b>Right.x = rightNoRoll.x * cos(rollRadians) +
				upNoRoll.x * sin(rollRadians)</b>, with similar calculations for the y and z components. Finally, the <b>Up</b> vector
			is recomputed as <b>normalize(cross(Right, Front))</b>. The camera tools capture mouse movement and update the
			appropriate vectors to be able to <i>pan</i>, <i>orbit</i>, <i>zoom</i>, <i>tilt</i>, <i>rotate</i>, and <i>roll</i>.
		</p>
		<p>
			The object manipulation tools use a transformation matrix, <b>matrix = translate * rotate * scale</b>, or position. Each
			tool modifies the appropriate parameters through mouse movements translated by sensitivity. For scaling, we increase or
			decrease the scale value and ensure there are valid values above the minimum thresholds: <b>Scale.x = fmax(0.01f,
				Scale.x + yoffset * ScaleSensitivity)</b>. Rotation transforms apply incremental changes to the Euler angles while
			ensuring they are normalized within a 0–360° range. Translation tools modify position directly.
		</p>
		<p>
			The reference grid provides a reference for size, position and orientation. It is implemented as a flat surface with a
			grid shader. The grid is generated in the <b>createGrid()</b> which creates a quad mesh with just four vertices at
			(±halfSize, 0, ±halfSize) to form the plane. The grid's rendering uses a dedicated fragment shader (<b>grid.frag</b>)
			that creates anti-aliased grid lines: <b>grid = abs(fract(coord - 0.5) - 0.5) / fwidth(coord)</b>, where <b>fract()</b>
			creates the repeated pattern and <b>fwidth()</b> creates consistent line thickness.
		</p>
		<h3>Sketch Shading</h3>
		For sketch shading, a lot of papers such as <a href="https://kylehalladay.com/blog/tutorial/2017/02/21/Pencil-Sketch-Effect.html">this</a> one used sketch textures of varying shading density and mapped it to the object. This felt a bit simple, so we decided to make a procedurally generated version. Using the same concept of varying sketch density with light we made a shader that used cross hatching to create a sketched look. One struggle we had is getting the generated cross hatching to look like natural pencil strokes rather than just diagonal lines. A couple ways we improved the organic look of the shader was by adding waviness to the lines, making the density gradient a power function rather than a linear function, and making the line colors a gradient of grayscale rather than just black and white.

		<h3>Cel Shading</h3>
		Cel is quite closely related to Blinn-Phong shading. We adapted the shading algorithm from homework 4, but this time we discretized the diffuse lighting component of the shader as mentioned in this <a href="https://panthavma.com/articles/shading/toonshading/">blog post</a>. This creates the effect of bands on the models which creates a cartoonish look. With out implementation, we played around with different thresholds and number of bands and landed on using three bands to create a visually appealing look, striking the balance between simplicity and complexity. We further simplified the look by removing the specular component to create a more matted look. One issue that we encountered was that for some models, mesh vertices were not particularly smooth but rather jaggered, this caused the bands to appear more patchy and less smooth (check out baby Groot model). However, we found that with the right model (and texture), we are able to create a very convincing model with cel shading (Link model)!

		<h3>Watercolor Shading</h3>
		The watercolor effect is related to the Phong shading model, but instead of using a simple diffuse and specular component, we use a more complex texture-based approach. We first sample the texture of the model and then apply a Gaussian blur to create a soft gradient effect. This simulates the blending of colors that occurs in watercolor painting. Additionally, we apply a bloom effect to enhance the light areas of the model, creating a glowing effect that is characteristic of watercolor paintings. The shader also incorporates noise to add a more organic feel to the rendering, mimicking the imperfections found in traditional watercolor art. Much like the sketch shader, current implementations of the watercolor shader often just use specular shading and textues to reate the watercolor look. We wanted to parameterize the process for more granular control over the final image.
	
		<br><br><hr>
		<h2>Results</h2>
		<h3>GUI</h3>
		<figure style="text-align: center;">

			<img src="img/gui.png" width="100%"/>
			<figcaption>GUI Window</figcaption>
		</figure>

		<h3>Link Model</h3>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
					<td style="text-align: center;">
						<img src="img/link_phong.png" width="350px"/>
						<figcaption>Standard (Phong) shading</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="img/link_sketch.png" width="350px"/>
						<figcaption>Sketch shading</figcaption>
					</td>
			  </tr>
				<tr>
					<td style="text-align: center;">
						<img src="img/link_cel.png" width="350px"/>
						<figcaption>Cel shading</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="img/link_watercolor.png" width="350px"/>
						<figcaption>Watercolor shading</figcaption>
					</td>
				</tr>
			</table>
		</div>
		<h3>Groot Model</h3>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
					<td style="text-align: center;">
						<img src="img/groot_phong.png" width="350px"/>
						<figcaption>Standard (Phong) shading</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="img/groot_sketch.png" width="350px"/>
						<figcaption>Sketch shading</figcaption>
					</td>
			  </tr>
				<tr>
					<td style="text-align: center;">
						<img src="img/groot_cel.png" width="350px"/>
						<figcaption>Cel shading</figcaption>
					</td>
					<td style="text-align: center;">
						<img src="img/watercolor.png" width="350px"/>
						<figcaption>Watercolor shading</figcaption>
					</td>
				</tr>
			</table>
		</div>
		<br><br><hr>
		<h2>References</h2>
		<li>Cel shading wikipedia<ul>
			<li><a href="https://en.wikipedia.org/wiki/Cel_shading">https://en.wikipedia.org/wiki/Cel_shading</a></li>
		</ul></li>
		<li>Cel shading history + mechanics<ul>
			<li><a href="https://www.youtube.com/watch?v=mnxs6CR6Zrk">https://www.youtube.com/watch?v=mnxs6CR6Zrk</a></li>
		</ul></li>
		<li>Toon shading fundamentals blog<ul>
			<li><a href="https://panthavma.com/articles/shading/toonshading/">https://panthavma.com/articles/shading/toonshading/</a></li>
		</ul></li>
		<li>Computer-generated watercolor<ul>
			<li><a href="https://dl.acm.org/doi/pdf/10.1145/258734.258896">https://dl.acm.org/doi/pdf/10.1145/258734.258896</a></li>
		</ul></li>
		<li>Watercolor inspired non photo-realistic rendering for augmented reality<ul>
			<li><a href="https://faculty.cc.gatech.edu/~turk/my_papers/npr_ar_2008.pdf">https://faculty.cc.gatech.edu/~turk/my_papers/npr_ar_2008.pdf</a></li>
		</ul></li>
		<li>Non-Photorealistic Rendering using Watercolor Inspired Textures and Illumination<ul>
			<li><a href="https://www.dimap.ufrn.br/~motta/dim102/Projetos/NPR/Lume_PG01.pdf">https://www.dimap.ufrn.br/~motta/dim102/Projetos/NPR/Lume_PG01.pdf</a></li>
		</ul></li>
		<li>Sketch effect blog: <ul>
			<li><a href="https://kylehalladay.com/blog/tutorial/2017/02/21/Pencil-Sketch-Effect.html">https://kylehalladay.com/blog/tutorial/2017/02/21/Pencil-Sketch-Effect.html</a></li>
		</ul></li>
		<li>Real-time hatching: <ul>
			<li><a href="https://hhoppe.com/hatching.pdf">https://hhoppe.com/hatching.pdf</a></li>
		</ul></li>

		<br><br><hr>
		<h2>Contribuition from each team member</h2>
		<h3>Lemuel Sumardy</h3>
		<p>I built upon Ryan's basic implementation of the GUI, by improving the UI/UX. This included features
			for camera control, model transformations, creating a reference plane, texture/color support, and general
			ease of use improvements.
		</p>
        <ul>
            <li>Ryan Kwong<ul>
                <li>Implemented sketch shader</li>
                <li>Creaed the basic design for the GUI</li>
            </ul></li>
			<li>Lemuel Sumardy<ul>
				<li>Added most of the features in the GUI</li>
				<li>Video editing</li>
			</ul></li>
			<li>Thomas Yeoh<ul>
				<li>Implemented cel shader</li>
			</ul></li>
			<li>Ziran Zhou<ul>
				<li>Implemented watercolor shader</li>
			</ul></li>
        </ul>
		</div>
	</body>
</html>